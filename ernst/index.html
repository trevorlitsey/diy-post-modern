<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>__ ernst</title>

	<!--
		Max Ernst
		Soleil rouge maritime
		Oil on glass
		1927
		21 x 17 5/8 in. (53.34 x 44.77 cm)
		https://collections.artsmia.org/art/61506/soleil-rouge-maritime-max-ernst

	-->

</head>

<body>
	<canvas resize></canvas>
	<style>
		body {
			margin: 0;
		}

		canvas {
			width: 100%;
			height: 100%;
			background: black;
		}
	</style>

	<script src="../js/paper-core.js"></script>
	<script>

		const getConfig = () => ({
			colors: {
				white: 'white',
				teal: '#73BAB7',
				orange: '#BC762D',
				blue: '#1D3765',
				green: '#293627',
				skyGradient: ['#01657D', '#54AABF', '#96CECE', '#C8EAEC', '#E2EEEA', '#E2EEEA', '#E2EEEA', '#E2EEEA'],
			},
			spacing: 4,
			width: window.innerWidth,
			height: window.innerHeight,
			group1: {
				length: Math.round(window.innerHeight * .03),
			},
			group2: {
				length: Math.round(window.innerHeight * .04),
				withRibbon: true,
			}
		})

		const p = paper;
		const canvas = document.querySelector('canvas');

		drawCanvas(getConfig());

		p.view.onResize = () => {
			requestAnimationFrame((() => drawCanvas(getConfig())))
		}

		// ----------------
		function drawCanvas(config) {
			p.setup(canvas);
			const group1Position = new p.Point(config.width / 2, config.height * .5);
			const group2Position = new p.Point(config.width / 2, config.height * .72);

			const sky = makeSky(config);
			const circle = makeCircle(config);
			const group1 = makeBrushGroup({ position: group1Position, length: config.group1.length, width: config.width * .7, color: config.colors.blue, strokeWidth: 2 });
			const group2 = makeBrushGroup({ position: group2Position, length: config.group2.length, width: config.width * .8, color: config.colors.green, strokeWidth: 2 }, withRibbon = config.group2.withRibbon);
		}

		function makeSky(config) {
			const path = new p.Path.Rectangle({
				topLeft: new p.Point(0, 0),
				bottomRight: new p.Point(config.width, config.height * .25),
				// Fill the path with a gradient of three color stops
				// that runs between the two points we defined earlier:
				fillColor: {
					gradient: {
						stops: config.colors.skyGradient,
					},
					origin: new p.Point(0, 0),
					destination: new p.Point(0, config.height * .3),
				}
			});
			return path;
		}

		function makeCircle(config) {
			// circle
			var shape = new p.Shape.Circle(new p.Point(config.width / 2, config.height * .21), config.width * .1 + config.height * .06);
			shape.strokeColor = config.colors.orange;

			// ribbon
			const segments = getSegments({ length: 14, waveHeight: 10, width: config.width * .46 });
			const ribbon = makeRibbon(segments, { color: config.colors.teal });
			ribbon.position = new p.Point(config.width / 2, config.height * .3)
		}

		function makeRibbon(segments, options = {}) {
			const o = {
				position: new p.Point(0, 0),
				...options,
			}
			const ribbon = new p.Path(segments);
			ribbon.strokeColor = o.color || '#73BAB7';
			ribbon.strokeWidth = 10;
			ribbon.smooth({ type: 'asymmetric' });
			ribbon.position = o.position;
			return ribbon;
		}

		function makeBrushGroup(options = {}, withRibbon = false) {
			const o = {
				position: new p.Point(0, 0),
				color: 'white',
				spacing: 4,
				length: 40,
				width: window.innerWidth,
				segmentsLength: 30,
				strokeWidth: 1,
				...options,
			}
			const segments = getSegments({ width: o.width, length: o.segmentsLength, })
			const lines = Array.from({ length: o.length }, () => makeBrushLine(segments, { color: o.color, strokeWidth: o.strokeWidth }))
			lines.forEach((line, index) => line.position.y += o.spacing * index);

			const group = new p.Group(lines);

			if (withRibbon) {
				const ribbon = makeRibbon([...segments.slice(2, segments.length - 2)], { position: o.position })
				ribbon.position.y += 20;
				ribbon.bringToFront();
			}

			group.position = o.position;
			return group;
		}

		function makeBrushLine(segments, options = {}) {
			const o = {
				color: 'white',
				strokeWidth: 1,
				...options,
			}
			const path = new p.Path(segments);
			path.strokeColor = {
				gradient: {
					stops: Array.from({ length: 6 }, () => Math.random() > .02 ? o.color : blendColors(o.color, '#fff', 90))
				},
				origin: new p.Point(0, 0),
				destination: new p.Point(window.innerWidth, 0),
			};
			path.strokeWidth = o.strokeWidth;
			path.smooth({ type: 'asymmetric' });
			return path;
		}

		function getSegments(options = {}) {
			const o = {
				length: 40,
				padding: 10,
				width: window.innerWidth,
				walk: .4,
				waveHeight: 16,
				...options,
			}
			return Array.from(
				{ length: o.length },
				(item, index) => {
					const walk = index > 0 && index < o.length - 1 ? Math.round(o.width / o.length * Math.random() * o.walk) : 0;
					const walkDirection = Math.random() > .5;

					const x = index * (o.width - o.padding) / o.length + o.padding + (walkDirection ? walk : -walk);
					const y = 100 + Math.round(Math.random() * o.waveHeight - (o.waveHeight / 2));
					return new p.Point(x, y)
				}
			);
		}

		// https://stackoverflow.com/questions/5560248/programmatically-lighten-or-darken-a-hex-color-or-rgb-and-blend-colors
		function blendColors(c0, c1, p) {
			var f = parseInt(c0.slice(1), 16), t = parseInt(c1.slice(1), 16), R1 = f >> 16, G1 = f >> 8 & 0x00FF, B1 = f & 0x0000FF, R2 = t >> 16, G2 = t >> 8 & 0x00FF, B2 = t & 0x0000FF;
			return "#" + (0x1000000 + (Math.round((R2 - R1) * p) + R1) * 0x10000 + (Math.round((G2 - G1) * p) + G1) * 0x100 + (Math.round((B2 - B1) * p) + B1)).toString(16).slice(1);
		}


	</script>
</body>

</html>